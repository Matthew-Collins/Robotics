' Gambas class file

Public Hat As MotorHat
Public Stepper As Integer

'Microstep Details:
Const MICROSTEPS As Integer = 8
Public MICROSTEP_CURVE[9] As Integer

'Variables:
Public Steps As Integer = 200
Public SecondsPerStep As Float = 0.1
Public SteppingCounter As Integer = 0
Public CurrentStep As Integer = 0

'Step Types:
Public Const SINGLE As Integer = 1
Public Const DOUBLE As Integer = 2
Public Const INTERLEAVE As Integer = 3
Public Const MICROSTEP As Integer = 4

Public PWMA As Integer
Public AIN2 As Integer
Public AIN1 As Integer
Public PWMB As Integer
Public BIN2 As Integer
Public BIN1 As Integer

Public Sub _new(MyHat As MotorHat, StepperNumber As Integer)

  Me.Hat = MyHat
  Me.Stepper = StepperNumber

  Me.MICROSTEP_CURVE = [0, 50, 98, 142, 180, 212, 236, 250, 255]

  Select Case StepperNumber
    Case 0
      Me.PWMA = 8
      Me.AIN2 = 9
      Me.AIN1 = 10
      Me.PWMB = 13
      Me.BIN2 = 12
      Me.BIN1 = 11
    Case 1
      Me.PWMA = 2
      Me.AIN2 = 3
      Me.AIN1 = 4
      Me.PWMB = 7
      Me.BIN2 = 6
      Me.BIN1 = 5
  End Select

  Me.SetSpeed(30)

End

Public Sub SetSpeed(RPM As Integer)
  Me.SecondsPerStep = 60 / (Me.Steps * RPM)
  Me.SteppingCounter = 0
End

Public Sub OneStep(Direction As Integer, StepStyle As Integer)
  
  ' 	def oneStep(self, dir, style):
' 		pwm_a = pwm_b = 255
' 
' 		#first determine what sort Of stepping procedure we 're up to
' 		If (style == Adafruit_MotorHAT.SINGLE):
'     			If ((self.currentstep / (self.MICROSTEPS / 2)) % 2): 
' 				#we 're at an odd step, weird
' 				If (dir == Adafruit_MotorHAT.FORWARD):
' 					self.currentstep += self.MICROSTEPS / 2
' 				else:
' 					self.currentstep -= self.MICROSTEPS / 2
' 			else:
' 				#go To Next even Step
' 				If (dir == Adafruit_MotorHAT.FORWARD):
' 					self.currentstep += self.MICROSTEPS
' 				else:
' 					self.currentstep -= self.MICROSTEPS
' 		If (style == Adafruit_MotorHAT.DOUBLE):
' 			If Not (self.currentstep / (self.MICROSTEPS / 2) % 2):
' 				#we 're at an even step, weird
' 				If (dir == Adafruit_MotorHAT.FORWARD):
' 					self.currentstep += self.MICROSTEPS / 2
' 				else:
' 					self.currentstep -= self.MICROSTEPS / 2
' 			else:
' 				#go To Next odd Step
' 				If (dir == Adafruit_MotorHAT.FORWARD):
' 					self.currentstep += self.MICROSTEPS
' 				else:
' 					self.currentstep -= self.MICROSTEPS
' 		If (style == Adafruit_MotorHAT.INTERLEAVE):
' 			If (dir == Adafruit_MotorHAT.FORWARD):
' 				self.currentstep += self.MICROSTEPS / 2
' 			else:
' 				self.currentstep -= self.MICROSTEPS / 2
' 
' 		If (style == Adafruit_MotorHAT.MICROSTEP):
' 			If (dir == Adafruit_MotorHAT.FORWARD):
' 				self.currentstep += 1
' 			else:
' 				self.currentstep -= 1
' 
'                 	#go To Next 'step' and wrap around
'                 	self.currentstep += self.MICROSTEPS * 4
'                 	self.currentstep %= self.MICROSTEPS * 4
' 
' 			pwm_a = pwm_b = 0
' 			If (self.currentstep >= 0) And (self.currentstep < self.MICROSTEPS):
' 				pwm_a = self.MICROSTEP_CURVE[self.MICROSTEPS - self.currentstep]
' 				pwm_b = self.MICROSTEP_CURVE[self.currentstep]
' 			elif(self.currentstep >= self.MICROSTEPS) And (self.currentstep < self.MICROSTEPS * 2):
' 				pwm_a = self.MICROSTEP_CURVE[self.currentstep - self.MICROSTEPS]
' 				pwm_b = self.MICROSTEP_CURVE[self.MICROSTEPS * 2 - self.currentstep]
' 			elif(self.currentstep >= self.MICROSTEPS * 2) And (self.currentstep < self.MICROSTEPS * 3):
' 				pwm_a = self.MICROSTEP_CURVE[self.MICROSTEPS * 3 - self.currentstep]
' 				pwm_b = self.MICROSTEP_CURVE[self.currentstep - self.MICROSTEPS * 2]
' 			elif(self.currentstep >= self.MICROSTEPS * 3) And (self.currentstep < self.MICROSTEPS * 4):
'                                 pwm_a = self.MICROSTEP_CURVE[self.currentstep - self.MICROSTEPS * 3]
'                                 pwm_b = self.MICROSTEP_CURVE[self.MICROSTEPS * 4 - self.currentstep]
' 
' 
' 		#go To Next 'step' and wrap around
' 		self.currentstep += self.MICROSTEPS * 4
' 		self.currentstep %= self.MICROSTEPS * 4
' 
' 		#only really used For microstepping, otherwise always on!
' 		self.MC._pwm.setPWM(self.PWMA, 0, pwm_a * 16)
' 		self.MC._pwm.setPWM(self.PWMB, 0, pwm_b * 16)
' 
' 		#set up coil energizing!
' 		coils = [0, 0, 0, 0]
' 
' 		If (style == Adafruit_MotorHAT.MICROSTEP):
' 			If (self.currentstep >= 0) And (self.currentstep < self.MICROSTEPS):
' 				coils = [1, 1, 0, 0]
'                         elif(self.currentstep >= self.MICROSTEPS) And (self.currentstep < self.MICROSTEPS * 2):
' 				coils = [0, 1, 1, 0]
'                         elif(self.currentstep >= self.MICROSTEPS * 2) And (self.currentstep < self.MICROSTEPS * 3):
' 				coils = [0, 0, 1, 1]
'                         elif(self.currentstep >= self.MICROSTEPS * 3) And (self.currentstep < self.MICROSTEPS * 4):
' 				coils = [1, 0, 0, 1]
' 		else:
' 			step2coils = [[1, 0, 0, 0], 
' 				[1, 1, 0, 0],
' 				[0, 1, 0, 0],
' 				[0, 1, 1, 0],
' 				[0, 0, 1, 0],
' 				[0, 0, 1, 1],
' 				[0, 0, 0, 1],
' 				[1, 0, 0, 1]]
' 			coils = step2coils[self.currentstep / (self.MICROSTEPS / 2)]
' 
' 		#Print "coils state = " + Str(coils)
' 		self.MC.setPin(self.AIN2, coils[0])
' 		self.MC.setPin(self.BIN1, coils[1])
' 		self.MC.setPin(self.AIN1, coils[2])
' 		self.MC.setPin(self.BIN2, coils[3])
' 
' 		Return self.currentstep
  
End

Public Sub Step(NumberOfSteps As Integer, Direction As Integer, StepStyle As Integer)

  Dim MySleepTime As Float = Me.SecondsPerStep
  Dim MyStep As Integer

  Select Case StepStyle
    Case INTERLEAVE
      MySleepTime /= 2
    Case MICROSTEPS
      MySleepTime /= MICROSTEPS
      NumberOfSteps *= MICROSTEPS
  End Select

  Print MySleepTime & " sec per step"

  For MyStep = 1 To NumberOfSteps
    Me.OneStep(Direction, StepStyle)
    Print "Step: " & MyStep
    Sleep MySleepTime
  Next

End



' #!/usr/bin/python
' 
' From Adafruit_PWM_Servo_Driver import PWM
' import Time
' 
' Class Adafruit_StepperMotor:
' 	MICROSTEPS = 8
' 	MICROSTEP_CURVE = [0, 50, 98, 142, 180, 212, 236, 250, 255]
' 
' 	#MICROSTEPS = 16
' 	#a sinusoidal curve Not LINEAR!
' 	#MICROSTEP_CURVE = [0, 25, 50, 74, 98, 120, 141, 162, 180, 197, 212, 225, 236, 244, 250, 253, 255]
' 	
' 	def __init__(self, controller, num, steps = 200):
' 		self.MC = controller
' 		self.revsteps = steps
' 		self.motornum = num
' 		self.sec_per_step = 0.1
' 		self.steppingcounter = 0
' 		self.currentstep = 0
' 
' 		num -= 1
' 
' 		If (num == 0):
' 			self.PWMA = 8
' 			self.AIN2 = 9
' 			self.AIN1 = 10
' 			self.PWMB = 13
' 			self.BIN2 = 12
' 			self.BIN1 = 11
' 		elif(num == 1):
' 			self.PWMA = 2
' 			self.AIN2 = 3
' 			self.AIN1 = 4
' 			self.PWMB = 7
' 			self.BIN2 = 6
' 			self.BIN1 = 5
' 		else:
' 			Raise NameError( 'MotorHAT Stepper must be between 1 and 2 inclusive')
' 
' 	def setSpeed(self, rpm):
' 		self.sec_per_step = 60.0 / (self.revsteps * rpm)
' 		self.steppingcounter = 0
' 
' 	def oneStep(self, dir, style):
' 		pwm_a = pwm_b = 255
' 
' 		#first determine what sort Of stepping procedure we 're up to
' 		If (style == Adafruit_MotorHAT.SINGLE):
'     			If ((self.currentstep / (self.MICROSTEPS / 2)) % 2): 
' 				#we 're at an odd step, weird
' 				If (dir == Adafruit_MotorHAT.FORWARD):
' 					self.currentstep += self.MICROSTEPS / 2
' 				else:
' 					self.currentstep -= self.MICROSTEPS / 2
' 			else:
' 				#go To Next even Step
' 				If (dir == Adafruit_MotorHAT.FORWARD):
' 					self.currentstep += self.MICROSTEPS
' 				else:
' 					self.currentstep -= self.MICROSTEPS
' 		If (style == Adafruit_MotorHAT.DOUBLE):
' 			If Not (self.currentstep / (self.MICROSTEPS / 2) % 2):
' 				#we 're at an even step, weird
' 				If (dir == Adafruit_MotorHAT.FORWARD):
' 					self.currentstep += self.MICROSTEPS / 2
' 				else:
' 					self.currentstep -= self.MICROSTEPS / 2
' 			else:
' 				#go To Next odd Step
' 				If (dir == Adafruit_MotorHAT.FORWARD):
' 					self.currentstep += self.MICROSTEPS
' 				else:
' 					self.currentstep -= self.MICROSTEPS
' 		If (style == Adafruit_MotorHAT.INTERLEAVE):
' 			If (dir == Adafruit_MotorHAT.FORWARD):
' 				self.currentstep += self.MICROSTEPS / 2
' 			else:
' 				self.currentstep -= self.MICROSTEPS / 2
' 
' 		If (style == Adafruit_MotorHAT.MICROSTEP):
' 			If (dir == Adafruit_MotorHAT.FORWARD):
' 				self.currentstep += 1
' 			else:
' 				self.currentstep -= 1
' 
'                 	#go To Next 'step' and wrap around
'                 	self.currentstep += self.MICROSTEPS * 4
'                 	self.currentstep %= self.MICROSTEPS * 4
' 
' 			pwm_a = pwm_b = 0
' 			If (self.currentstep >= 0) And (self.currentstep < self.MICROSTEPS):
' 				pwm_a = self.MICROSTEP_CURVE[self.MICROSTEPS - self.currentstep]
' 				pwm_b = self.MICROSTEP_CURVE[self.currentstep]
' 			elif(self.currentstep >= self.MICROSTEPS) And (self.currentstep < self.MICROSTEPS * 2):
' 				pwm_a = self.MICROSTEP_CURVE[self.currentstep - self.MICROSTEPS]
' 				pwm_b = self.MICROSTEP_CURVE[self.MICROSTEPS * 2 - self.currentstep]
' 			elif(self.currentstep >= self.MICROSTEPS * 2) And (self.currentstep < self.MICROSTEPS * 3):
' 				pwm_a = self.MICROSTEP_CURVE[self.MICROSTEPS * 3 - self.currentstep]
' 				pwm_b = self.MICROSTEP_CURVE[self.currentstep - self.MICROSTEPS * 2]
' 			elif(self.currentstep >= self.MICROSTEPS * 3) And (self.currentstep < self.MICROSTEPS * 4):
'                                 pwm_a = self.MICROSTEP_CURVE[self.currentstep - self.MICROSTEPS * 3]
'                                 pwm_b = self.MICROSTEP_CURVE[self.MICROSTEPS * 4 - self.currentstep]
' 
' 
' 		#go To Next 'step' and wrap around
' 		self.currentstep += self.MICROSTEPS * 4
' 		self.currentstep %= self.MICROSTEPS * 4
' 
' 		#only really used For microstepping, otherwise always on!
' 		self.MC._pwm.setPWM(self.PWMA, 0, pwm_a * 16)
' 		self.MC._pwm.setPWM(self.PWMB, 0, pwm_b * 16)
' 
' 		#set up coil energizing!
' 		coils = [0, 0, 0, 0]
' 
' 		If (style == Adafruit_MotorHAT.MICROSTEP):
' 			If (self.currentstep >= 0) And (self.currentstep < self.MICROSTEPS):
' 				coils = [1, 1, 0, 0]
'                         elif(self.currentstep >= self.MICROSTEPS) And (self.currentstep < self.MICROSTEPS * 2):
' 				coils = [0, 1, 1, 0]
'                         elif(self.currentstep >= self.MICROSTEPS * 2) And (self.currentstep < self.MICROSTEPS * 3):
' 				coils = [0, 0, 1, 1]
'                         elif(self.currentstep >= self.MICROSTEPS * 3) And (self.currentstep < self.MICROSTEPS * 4):
' 				coils = [1, 0, 0, 1]
' 		else:
' 			step2coils = [[1, 0, 0, 0], 
' 				[1, 1, 0, 0],
' 				[0, 1, 0, 0],
' 				[0, 1, 1, 0],
' 				[0, 0, 1, 0],
' 				[0, 0, 1, 1],
' 				[0, 0, 0, 1],
' 				[1, 0, 0, 1]]
' 			coils = step2coils[self.currentstep / (self.MICROSTEPS / 2)]
' 
' 		#Print "coils state = " + Str(coils)
' 		self.MC.setPin(self.AIN2, coils[0])
' 		self.MC.setPin(self.BIN1, coils[1])
' 		self.MC.setPin(self.AIN1, coils[2])
' 		self.MC.setPin(self.BIN2, coils[3])
' 
' 		Return self.currentstep
' 
' 	def step(self, steps, direction, stepstyle):
' 		s_per_s = self.sec_per_step
' 		lateststep = 0
' 		
' 		If (stepstyle == Adafruit_MotorHAT.INTERLEAVE):
' 			s_per_s = s_per_s / 2.0
' 		If (stepstyle == Adafruit_MotorHAT.MICROSTEP):
' 			s_per_s /= self.MICROSTEPS
' 			steps *= self.MICROSTEPS
' 
' 		Print s_per_s, " sec per step"
' 
' 		For s In range(steps):
' 			lateststep = self.oneStep(direction, stepstyle)
' 			time.sleep(s_per_s)
' 
' 		If (stepstyle == Adafruit_MotorHAT.MICROSTEP):
' 			#this Is An edge Case , If we are In between full steps, lets just keep going
' 			#so we End On a full Step
' 			While (lateststep! = 0) And (lateststep! = self.MICROSTEPS):
' 				lateststep = self.oneStep(dir, stepstyle)
' 				time.sleep(s_per_s)

' 